<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Rad Blog</title>
    <link>https://xfrnk2.github.io/algorithm/</link>
    <description>Recent content in Algorithms on Rad Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 07 Jul 2021 15:55:01 +0900</lastBuildDate>
    <atom:link href="https://xfrnk2.github.io/algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>피보나치 수열로 본 동적 프로그래밍(Dynamic Programming)</title>
      <link>https://xfrnk2.github.io/algorithm/fib_dynamic_programming/</link>
      <pubDate>Wed, 07 Jul 2021 15:55:01 +0900</pubDate>
      <guid>https://xfrnk2.github.io/algorithm/fib_dynamic_programming/</guid>
      <description>차례 Memoization Tabluation 공간 최적화 1. Memoization &amp;gt; 특징 재귀함수를 사용한다. 필요한 만큼만, 불필요한 경우는 제외하여 구한다. 필요한 계산을 요구, 필요하지 않은 경우는 요구하지 않응. 단, 최대 재귀호출 깊이에 제한을 받을 수 있음. Code def fib_memo(n, cache):if n &amp;lt; 3:return 1# 이미 n번째 피보나치를 계산했으면 저장된 값을 바로 리턴한다.if n in cache:return cache[n]cache[n] = fib_memo(n - 1, cache) + fib_memo(n - 2, cache)return cache[n]def fib(n):# n번째 피보나치 수를 담는 사전fib_cache = {}return fib_memo(n, fib_cache)# testprint(fib(10))print(fib(50))print(fib(100)) 2.</description>
    </item>
    <item>
      <title>정렬 알고리즘 - 선택 정렬(Selection Sort)</title>
      <link>https://xfrnk2.github.io/algorithm/selection_sort/</link>
      <pubDate>Tue, 14 Jul 2020 15:55:01 +0900</pubDate>
      <guid>https://xfrnk2.github.io/algorithm/selection_sort/</guid>
      <description>선택정렬의 원리와 특징 및 성능에 대해서 정리하는 글이다.
&amp;lt;학습 목표&amp;gt;
선택정렬의 원리를 이해한다. 선택정렬의 특징을 파악한다. 선택정렬의 성능을 기억한다. 모든 과정을 설명할 수 있다. 선택정렬을 프로그래밍 언어로 구현할 수 있다. 선택정렬의 원리 비교 연산을 통해 주어진 배열의 최솟값을 탐색 배열의 가장 앞에있는 원소와 최솟값을 교환 나머지 미정렬 부분을 가지고 위의 과정을 반복 선택정렬의 정렬 과정 배열의 크기 = n = 5,
최솟값의 인덱스 = least_index
[5, 3, 4, 2, 1] 0번째와 1~4번째값을 비교하여 보다 작은 값의 index를 least_index에 저장한다.</description>
    </item>
    <item>
      <title>정렬 알고리즘 - 버블 정렬(Bubble Sort)</title>
      <link>https://xfrnk2.github.io/algorithm/bubble_sort/</link>
      <pubDate>Fri, 10 Jul 2020 00:08:44 +0900</pubDate>
      <guid>https://xfrnk2.github.io/algorithm/bubble_sort/</guid>
      <description>버블정렬의 원리와 특징 및 성능에 대해서 정리하는 글이다.
&amp;lt;학습 목표&amp;gt;
버블정렬의 원리를 이해한다. 버블정렬의 특징을 파악한다. 버블정렬의 성능을 기억한다. 모든 과정을 설명할 수 있다. 버블정렬을 프로그래밍 언어로 구현할 수 있다. 버블정렬의 원리 모든 인접한 값의 비교를 위해 왼쪽 또는 오른쪽에서 시작하여 반대편 끝으로 이동 인접한 두 값을 비교하여 왼쪽 값이 더 큰 경우 자리를 바꾸는 과정을 반복 버블정렬의 정렬 과정 가장 오른쪽 값(최댓값)부터 왼쪽 방향(최솟값 방향)으로 정렬되는 과정을 설명 비교연산의 기준이 되는 시작하는 위치는 가장 끝에서 가장 끝 바로 하나 전의 위치까지, 진행 방향으로 1씩 이동 배열의 크기 = n = 5</description>
    </item>
  </channel>
</rss>
