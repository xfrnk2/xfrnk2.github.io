<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programmers on Rad Blog</title>
    <link>https://xfrnk2.github.io/categories/programmers/</link>
    <description>Recent content in Programmers on Rad Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 26 Jan 2022 19:15:16 +0900</lastBuildDate>
    
	<atom:link href="https://xfrnk2.github.io/categories/programmers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>프로그래머스-해시-완주하지 못한 선수</title>
      <link>https://xfrnk2.github.io/programmers/hash_marathon_lv1/</link>
      <pubDate>Wed, 26 Jan 2022 19:15:16 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/hash_marathon_lv1/</guid>
      <description>프로그래머스-해시-완주하지 못한 선수로 이동  첫 성공시도 def solution(participant, completion): answer = &amp;quot;&amp;quot; counts = dict() for i in completion: counts[i] = counts.get(i, 0) + 1 for name in participant: value = counts.get(name) if value == None or value &amp;lt;= 0: answer = name break counts[name] -= 1 return answer 셀프 피드백  복잡하다. 더 간단히 할 수는 없을까?   두번째 성공시도 from collections import Counter def solution(participant, completion): i = iter((Counter(participant) - Counter(completion)).</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 문자열 변환</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_target_word_transformation/</link>
      <pubDate>Tue, 02 Nov 2021 15:53:47 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_target_word_transformation/</guid>
      <description>from collections import deque def solution(begin, target, words): def check(s1, s2): res = 0 for i in range(len(s1)): if s1[i] == s2[i]: res += 1 if res &amp;gt;= len(s1) - 1: return True return False queue = deque() queue.append([begin, words, 0]) while queue: value, path, c = queue.popleft() if value == target: return c for i, j in enumerate(path): if check(value, j): new_path = path[:] new_value = new_path.pop(i) queue.append([new_value, new_path, c + 1]) return ans 한마디  이틀이나 잡아먹은 문제이다.</description>
    </item>
    
    <item>
      <title>프로그래머스 완전탐색 - 모의 고사</title>
      <link>https://xfrnk2.github.io/programmers/brute_force_mock_test/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:46 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/brute_force_mock_test/</guid>
      <description>def solution(answers): N = len(answers) d1 = [1, 2, 3, 4, 5] * (N // 5 + 1) d2 = [2, 1, 2, 3, 2, 4, 2, 5] * (N // 8 + 1) d3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] * (N // 10 + 1) user = [0] * 3 for i in range(len(answers)): if d1[i] == answers[i]: user[0] += 1 if d2[i] == answers[i]: user[1] += 1 if d3[i] == answers[i]: user[2] += 1 m = max(user) ans = [] for i, u in enumerate(user): if u == m: ans.</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 여행 경로</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_target_travel_path/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:45 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_target_travel_path/</guid>
      <description>from collections import defaultdict def solution(tickets): def init_graph(): graph = defaultdict(list) for key, destination in tickets: graph[key].append(destination) return graph def dfs(): stack = [&#39;ICN&#39;] path = [] while len(stack) &amp;gt; 0: top = stack[-1] if top not in routes or len(routes[top]) == 0: path.append(stack.pop()) else: stack.append(routes[top].pop(0)) return path[::-1] routes = init_graph() for r in routes: routes[r].sort() answer = dfs() return answer # 재귀를 사용한 풀이 - 조금의 비교(참고 코드)를 거쳐 가며 손코딩 from collections import defaultdict def solution(tickets): def init_graph(): graph = defaultdict(list) for key, destination in tickets: graph[key].</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 타겟 넘버</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_target_number/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:44 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_target_number/</guid>
      <description># lv2 # dfs def solution(numbers, target): ans = 0 def func(num, level): nonlocal ans if level == len(numbers): if target == num: ans += 1 return if level == 1: func(- num + numbers[level], level + 1) func(- num - numbers[level], level + 1) func(num + numbers[level], level + 1) func(num - numbers[level], level + 1) func(numbers[0], 1) return ans # bfs from collections import deque def solution(numbers, target): ans = 0 queue = deque() queue.</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 네트워크</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_network/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:43 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_network/</guid>
      <description># lv3 def solution(n, computers): d = [0] * n ans = 0 def func(idx): d[idx] = 1 for j, k in enumerate(computers[idx]): if j != idx and k == 1 and d[j] != 1: func(j) for i in range(n): if d[i] == 0: ans += 1 func(i) return ans 한마디 </description>
    </item>
    
    <item>
      <title>프로그래머스 완전탐색 - 소수 찾기</title>
      <link>https://xfrnk2.github.io/programmers/brute_force_decimal_search/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:40 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/brute_force_decimal_search/</guid>
      <description>from itertools import permutations def solution(numbers): ans = 0 container = [] for i in range(1, len(numbers) + 1): dp = ((permutations(numbers, i))) for d in dp: container.append(int(&#39;&#39;.join(d))) container = set(container) def check(n): if n &amp;lt;= 1: return True t = 2 t2 = n ** 0.5 while t &amp;lt;= t2: if n % t == 0: return True t += 1 return False for n in container: if not check(n): ans += 1 return ans 한마디  배울 수 있었던 것 : 조합을 구하는 방법과 처리 (여러번을 해도 숙달되지 않은 상황이다.</description>
    </item>
    
    <item>
      <title>프로그래머스 스킬체크 Lv2_211024</title>
      <link>https://xfrnk2.github.io/programmers/skillchecklv2/</link>
      <pubDate>Sun, 24 Oct 2021 14:52:46 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/skillchecklv2/</guid>
      <description>1번 문제 성공 실패 결정 요인: 좌표1=(x1, y1) &amp;lt; 좌표2=(x2, y2)가 보장되어야 하고, * 집합은 ((0, 0), (1, 1))과 ((1, 1), (0, 0))을 다른 요소로 취급한다. def solution(dirs): curX = 0 curY = 0 visits = set() for d in dirs: if d == &#39;U&#39; and curY &amp;lt; 5: visits.add(((curY, curX),(curY + 1, curX))) curY += 1 elif d == &#39;D&#39; and curY &amp;gt; -5: visits.add(((curY - 1, curX),(curY, curX))) curY -= 1 elif d == &#39;R&#39; and curX &amp;lt; 5: visits.</description>
    </item>
    
    <item>
      <title>프로그래머스-정렬-가장 큰 수[정렬]</title>
      <link>https://xfrnk2.github.io/programmers/the_biggest_number/</link>
      <pubDate>Tue, 13 Oct 2020 15:52:46 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/the_biggest_number/</guid>
      <description>프로그래머스-정렬-가장 큰 수[정렬]문제 바로가기  나의 파이썬 풀이 def solution(numbers): numbers = map(str, numbers) answer = &#39;&#39;.join(sorted(numbers, reverse=True, key=lambda n: (n[0], n[1 % len(n)], n[2 % len(n)], n[3 % len(n)]))) return answer if int(answer) else &#39;0&#39;  Javascript 풀이 해석  친구 말로는 해당 문제의 블로그 등 온라인 상의 Javascript 풀이의 100% 아래와 같은 형태를 하고 있는데, sort 함수의 (b+a)-(a+b)가 이해가 어렵다고 하여 어떻게 설명할 수 있을지 알아보게 되었다.
 function solution(numbers) { var answer = numbers.</description>
    </item>
    
  </channel>
</rss>