<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programmers on Rad Blog</title>
    <link>https://xfrnk2.github.io/programmers/</link>
    <description>Recent content in Programmers on Rad Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 14 Feb 2022 14:15:16 +0900</lastBuildDate>
    
	<atom:link href="https://xfrnk2.github.io/programmers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>프로그래머스-해시-베스트 앨범</title>
      <link>https://xfrnk2.github.io/programmers/hash_bestalbum_lv3/</link>
      <pubDate>Mon, 14 Feb 2022 14:15:16 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/hash_bestalbum_lv3/</guid>
      <description>[프로그래머스-해시-베스트 앨범(으)로 이동](https://programmers.co.kr/learn/courses/30/lessons/42579  실패한 첫 시도 from collections import defaultdict def solution(genres, plays): d = defaultdict(list) for i in range(len(genres)): d[genres[i]].append((plays[i], i)) for i in d.keys(): d[i].sort(key=lambda x : (-x[0], x[1])) nd = sorted(list(d.keys()), key = lambda c: list(map(lambda i: i[0], d[c])), reverse=True) return [y[1] for x in [d[g][:2] for g in nd] for y in x] 셀프 피드백  defaultdict를 사용했다. nd 변수 라인의 가독성이 떨어진다. 5~14번 테스트 케이스가 실패한다.</description>
    </item>
    
    <item>
      <title>프로그래머스-해시-위장</title>
      <link>https://xfrnk2.github.io/programmers/hash_camouflage_lv2/</link>
      <pubDate>Fri, 04 Feb 2022 14:15:16 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/hash_camouflage_lv2/</guid>
      <description>[프로그래머스-해시-위장(으)로 이동](https://programmers.co.kr/learn/courses/30/lessons/42578  실패한 첫 시도  첫 시도에 방법이 떠오르지 않아 1-2시간 가량 고민 후 검색해 나온 결과를 참고하였다.  첫번째로 작성한 통과 코드 def solution(clothes): answer = 1 clothes_count = {} for item, category in clothes: if category not in clothes_count: clothes_count[category] = 2 continue clothes_count[category] += 1 for num in clothes_count.values(): answer *= num return answer - 1  각 종류별 옷을 착용하지 않는 경우를 생각해서 1을 더해주었고, 최종적으로 모두 입지 않는 경우를 제하기 위해 1을 빼 주었다.</description>
    </item>
    
    <item>
      <title>프로그래머스-해시-전화번호 목록</title>
      <link>https://xfrnk2.github.io/programmers/hash_phone_number_list_lv2/</link>
      <pubDate>Thu, 27 Jan 2022 14:15:16 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/hash_phone_number_list_lv2/</guid>
      <description>프로그래머스-해시-전화번호 목록(으)로 이동  실패한 첫 시도 phone_book.sort(key=len) for i in range(len(phone_book)): for j in range(i+1, len(phone_book): ... 셀프 피드백  막연한 생각으로 len 기준으로 정렬을 사용했다. for문이 2중이기 때문에 효율성 실패가 나왔다.   고민 끝에 다른 풀이를 참고하도록 했다.  hash() 함수 또는 해시 자료구조(dictionary)를 쓰기위해 고민했는데 좀처럼 좋은 방법을 찾지 못했다.   문자열을 소팅했을때 일어나는 변화 &amp;gt;&amp;gt;&amp;gt; a = [&amp;quot;1225&amp;quot;, &amp;quot;123&amp;quot;, &amp;quot;12348&amp;quot;, &amp;quot;012&amp;quot;, &amp;quot;012222&amp;quot;, &amp;quot;12448&amp;quot;] &amp;gt;&amp;gt;&amp;gt; a.</description>
    </item>
    
    <item>
      <title>프로그래머스-해시-완주하지 못한 선수</title>
      <link>https://xfrnk2.github.io/programmers/hash_marathon_lv1/</link>
      <pubDate>Wed, 26 Jan 2022 19:15:16 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/hash_marathon_lv1/</guid>
      <description>프로그래머스-해시-완주하지 못한 선수로 이동  첫 성공시도 def solution(participant, completion): answer = &amp;quot;&amp;quot; counts = dict() for i in completion: counts[i] = counts.get(i, 0) + 1 for name in participant: value = counts.get(name) if value == None or value &amp;lt;= 0: answer = name break counts[name] -= 1 return answer 셀프 피드백  복잡하다. 더 간단히 할 수는 없을까?   두번째 성공시도 from collections import Counter def solution(participant, completion): i = iter((Counter(participant) - Counter(completion)).</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 문자열 변환</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_target_word_transformation/</link>
      <pubDate>Tue, 02 Nov 2021 15:53:47 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_target_word_transformation/</guid>
      <description>from collections import deque def solution(begin, target, words): def check(s1, s2): res = 0 for i in range(len(s1)): if s1[i] == s2[i]: res += 1 if res &amp;gt;= len(s1) - 1: return True return False queue = deque() queue.append([begin, words, 0]) while queue: value, path, c = queue.popleft() if value == target: return c for i, j in enumerate(path): if check(value, j): new_path = path[:] new_value = new_path.pop(i) queue.append([new_value, new_path, c + 1]) return ans 한마디  이틀이나 잡아먹은 문제이다.</description>
    </item>
    
    <item>
      <title>프로그래머스 완전탐색 - 모의 고사</title>
      <link>https://xfrnk2.github.io/programmers/brute_force_mock_test/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:46 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/brute_force_mock_test/</guid>
      <description>def solution(answers): N = len(answers) d1 = [1, 2, 3, 4, 5] * (N // 5 + 1) d2 = [2, 1, 2, 3, 2, 4, 2, 5] * (N // 8 + 1) d3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5] * (N // 10 + 1) user = [0] * 3 for i in range(len(answers)): if d1[i] == answers[i]: user[0] += 1 if d2[i] == answers[i]: user[1] += 1 if d3[i] == answers[i]: user[2] += 1 m = max(user) ans = [] for i, u in enumerate(user): if u == m: ans.</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 여행 경로</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_target_travel_path/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:45 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_target_travel_path/</guid>
      <description>from collections import defaultdict def solution(tickets): def init_graph(): graph = defaultdict(list) for key, destination in tickets: graph[key].append(destination) return graph def dfs(): stack = [&#39;ICN&#39;] path = [] while len(stack) &amp;gt; 0: top = stack[-1] if top not in routes or len(routes[top]) == 0: path.append(stack.pop()) else: stack.append(routes[top].pop(0)) return path[::-1] routes = init_graph() for r in routes: routes[r].sort() answer = dfs() return answer # 재귀를 사용한 풀이 - 조금의 비교(참고 코드)를 거쳐 가며 손코딩 from collections import defaultdict def solution(tickets): def init_graph(): graph = defaultdict(list) for key, destination in tickets: graph[key].</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 타겟 넘버</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_target_number/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:44 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_target_number/</guid>
      <description># lv2 # dfs def solution(numbers, target): ans = 0 def func(num, level): nonlocal ans if level == len(numbers): if target == num: ans += 1 return if level == 1: func(- num + numbers[level], level + 1) func(- num - numbers[level], level + 1) func(num + numbers[level], level + 1) func(num - numbers[level], level + 1) func(numbers[0], 1) return ans # bfs from collections import deque def solution(numbers, target): ans = 0 queue = deque() queue.</description>
    </item>
    
    <item>
      <title>프로그래머스 DFS/BFS - 네트워크</title>
      <link>https://xfrnk2.github.io/programmers/dfsbfs_network/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:43 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/dfsbfs_network/</guid>
      <description># lv3 def solution(n, computers): d = [0] * n ans = 0 def func(idx): d[idx] = 1 for j, k in enumerate(computers[idx]): if j != idx and k == 1 and d[j] != 1: func(j) for i in range(n): if d[i] == 0: ans += 1 func(i) return ans 한마디 </description>
    </item>
    
    <item>
      <title>프로그래머스 완전탐색 - 소수 찾기</title>
      <link>https://xfrnk2.github.io/programmers/brute_force_decimal_search/</link>
      <pubDate>Tue, 02 Nov 2021 15:52:40 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/brute_force_decimal_search/</guid>
      <description>from itertools import permutations def solution(numbers): ans = 0 container = [] for i in range(1, len(numbers) + 1): dp = ((permutations(numbers, i))) for d in dp: container.append(int(&#39;&#39;.join(d))) container = set(container) def check(n): if n &amp;lt;= 1: return True t = 2 t2 = n ** 0.5 while t &amp;lt;= t2: if n % t == 0: return True t += 1 return False for n in container: if not check(n): ans += 1 return ans 한마디  배울 수 있었던 것 : 조합을 구하는 방법과 처리 (여러번을 해도 숙달되지 않은 상황이다.</description>
    </item>
    
    <item>
      <title>프로그래머스 스킬체크 Lv2_211024</title>
      <link>https://xfrnk2.github.io/programmers/skillchecklv2/</link>
      <pubDate>Sun, 24 Oct 2021 14:52:46 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/skillchecklv2/</guid>
      <description>1번 문제 성공 실패 결정 요인: 좌표1=(x1, y1) &amp;lt; 좌표2=(x2, y2)가 보장되어야 하고, * 집합은 ((0, 0), (1, 1))과 ((1, 1), (0, 0))을 다른 요소로 취급한다. def solution(dirs): curX = 0 curY = 0 visits = set() for d in dirs: if d == &#39;U&#39; and curY &amp;lt; 5: visits.add(((curY, curX),(curY + 1, curX))) curY += 1 elif d == &#39;D&#39; and curY &amp;gt; -5: visits.add(((curY - 1, curX),(curY, curX))) curY -= 1 elif d == &#39;R&#39; and curX &amp;lt; 5: visits.</description>
    </item>
    
    <item>
      <title>프로그래머스-정렬-가장 큰 수[정렬]</title>
      <link>https://xfrnk2.github.io/programmers/the_biggest_number/</link>
      <pubDate>Tue, 13 Oct 2020 15:52:46 +0900</pubDate>
      
      <guid>https://xfrnk2.github.io/programmers/the_biggest_number/</guid>
      <description>프로그래머스-정렬-가장 큰 수[정렬]문제 바로가기  나의 파이썬 풀이 def solution(numbers): numbers = map(str, numbers) answer = &#39;&#39;.join(sorted(numbers, reverse=True, key=lambda n: (n[0], n[1 % len(n)], n[2 % len(n)], n[3 % len(n)]))) return answer if int(answer) else &#39;0&#39;  Javascript 풀이 해석  친구 말로는 해당 문제의 블로그 등 온라인 상의 Javascript 풀이의 100% 아래와 같은 형태를 하고 있는데, sort 함수의 (b+a)-(a+b)가 이해가 어렵다고 하여 어떻게 설명할 수 있을지 알아보게 되었다.
 function solution(numbers) { var answer = numbers.</description>
    </item>
    
  </channel>
</rss>